\capitulo{4}{Técnicas y herramientas}

\section{Técnicas}

\subsection{Scrum}

Scrum es una metodología de desarrollo ágil basada en los principios del
manifiesto ágil\footnote{\url{http://agilemanifesto.org/}}. Esta metodología
esta pensada para equipos por lo que ha sido adaptada para el desarrollo de este
proyecto.

Scrum consiste en ciclos de trabajo iterativos denominados \textit{sprints}, con
duración de una semana generalmente, en los que al terminar se entrega un
producto funcional. Al final de cada \textit{sprint} se lleva a cabo una reunión
con los tutores para comentar el desarrollo del \textit{sprint}, enseñar los
avances y planear el siguiente ciclo de desarrollo.

El uso de esta metodología permite la entrega de un producto de forma
incremental, además de soportar cambios en los requisitos durante el desarrollo
teniendo en cuenta el \textit{feedback} del usuario, consiguiendo al final un
producto de más calidad y valor para el usuario.

\subsection{Kanban}

Kanban se refiere a un sistema de organización visual de tareas, representadas
como tarjetas, organizadas en diferentes tableros según el estado de desarrollo
en que se encuentren.

Este sistema encaja perfectamente con la metodología Scrum, organizando las
tareas de cada \textit{sprint} para una mayor planificación. Esto permite
centrarse en las tareas que están desarrollo, mantener un registro de las tareas
terminadas y que no se pierdan tareas que están por hacer.

\section{Control de versiones y gestión del proyecto}

\subsection{Git}

Git es un sistema de control de versiones distribuido. No se han considerado
otras alternativas al ser un sistema ya conocido. Actualmente puede ser
considerado el sistema con más usuarios y de más fama.

\subsection{Repositorio remoto}

\begin{itemize}
	\tightlist
	\item Herramientas consideradas: \hrefFootnote{https://github.com/}{GitHub},
	\hrefFootnote{https://bitbucket.org}{Bitbucket},
	\hrefFootnote{https://about.gitlab.com/}{GitLab}
	\item Herramienta escogida: GitHub
\end{itemize}

GitHub es un servicio de alojamiento de repositorios de código basado en
\textit{Git}.

Esta plataforma se ha utilizado para alojar el proyecto, gestionar las tareas
mediante \textit{Issues} y planificar \textit{sprints} mediante
\textit{Milestones}.

La principal razón para escoger esta plataforma es la experiencia previa además
de haber trabajado en ella en asignaturas del grado.

\subsection{Tablero kanban}

\begin{itemize}
	\tightlist
	\item Herramientas consideradas:
	\hrefFootnote{https://www.zenhub.com/}{ZenHub},
	\hrefFootnote{https://www.gitkraken.com/glo}{GitKraken Glo}
	\item Herramienta escogida: ZenHub
\end{itemize}

ZenHub es una herramienta que ofrece tableros kanban para organizar las tareas
de un proyecto. Esta herramienta se integra dentro de GitHub permitiendo tener
toda la gestión centralizada en un mismo lugar.

Las \textit{Issues} de GitHub se representan como tarjetas que organizar en los
tableros. También ofrece la creación de gráficos \textit{burndown} para
visualizar el desarrollo del \textit{sprint}. 

Al igual que en el caso anterior, se ha escogido por tener experiencia previa en
asignaturas del grado.

\subsection{Interfaz gráfico}

\begin{itemize}
	\tightlist
	\item Herramientas consideradas:
	\hrefFootnote{https://www.sourcetreeapp.com/}{Sourcetree},
	\hrefFootnote{https://www.gitkraken.com/}{GitKraken},
	\hrefFootnote{https://desktop.github.com/}{GitHub Desktop}
	\item Herramienta escogida: GitKraken
\end{itemize}

GitKraken es un \textit{software} que proporciona una interfaz gráfica al
sistema \textit{Git} permitiendo realizar todas sus acciones de una forma más
sencilla y visual. Se puede enlazar con los repositorios remotos principales y
está disponible para Windows, Mac y Linux.

Aunque se ha trabajado con las tres herramientas mencionadas, se ha elegido por
ser actualmente la única de ellas disponible para Linux. La versión Pro de este programa está incluida dentro del \hrefFootnote{https://education.github.com/pack}{Student Developer Pack}.

\section{Herramientas}

\subsection{Flask}

Una de las condiciones iniciales del proyecto es el uso de Python para desarrollar el servidor web con el \textit{framework} \hrefFootnote{http://flask.pocoo.org/}{Flask}.

Este \textit{framework} es bastante fácil de utilizar y no impone ninguna limitación respecto a estructura del proyecto ni a los componentes que usar durante el desarrollo~\cite{grinberg2014flask}.

Debido a su simplicidad tiene bastantes carencias respecto a funcionalidades avanzadas pero gracias a los complementos que la gran comunidad que se ha formado a su alrededor ha desarrollado deja de ser un problema.

\subsection{Scikit-learn}

\hrefFootnote{http://scikit-learn.org}{Scikit-learn}~\cite{art:scikit-learn} es una librería de aprendizaje automático en Python. Contiene una amplia cantidad de algoritmos de clasificación, regresión y \textit{clustering}.

Esta librería proporciona los modelos usados en el proyecto, así como las funciones para calcular las estadísticas de los modelos entrenados.

\subsection{Entorno de desarrollo integrado (IDE}

\begin{itemize}
	\tightlist
	\item Herramientas consideradas: \hrefFootnote{https://www.jetbrains.com/pycharm/}{PyCharm}, \hrefFootnote{https://atom.io/}{Atom}, \hrefFootnote{https://code.visualstudio.com/}{VS Code}
	\item Herramienta escogida: PyCharm
\end{itemize}

PyCharm es un IDE desarrollado por la empresa JetBrains para el lenguaje Python. Existen dos ediciones, \textit{Community} y \textit{Professional}. Gracias al programa \hrefFootnote{https://www.jetbrains.com/student/}{For Students} de JetBrains se está usando la versión \textit{Professional} en el proyecto, aunque la \textit{Community} serviría perfectamente.

Ofrece soporte para Flask de serie y soporte para desarrollo web mediante complementos, razones principales de la elección.

\subsection{Documentación}

\begin{itemize}
	\tightlist
	\item Herramientas consideradas: \LaTeX, Microsoft Office, Libre Office
	\item Herramienta escogida: \LaTeX
\end{itemize}

\LaTeX es un lenguaje orientado a la creación de documentos que presenten alta calidad tipográfica.

Aunque su curva de aprendizaje es elevada, posee grande ventajas como no tener que preocuparse del formato del documento o que los textos no pierdan calidad al ser ampliados o impresos.

\subsection{Calidad del código}

\begin{itemize}
	\tightlist
	\item Herramientas consideradas: \hrefFootnote{https://www.codacy.com/}{Codacy}, \hrefFootnote{https://codeclimate.com/}{Code Climate}
	\item Herramienta escogida: Codacy
\end{itemize}

Codacy es una herramienta de revisión automática de código. Se integra con GitHub y analiza los proyectos que se hayan seleccionado cuando se produce un \textit{push} al repositorio.

Esta herramienta detecta problemas de seguridad, de estilo de código, complejidad, código duplicado y código duplicado. Con estos datos se elaboran gráficos históricos de la evolución del proyecto.

Después de los análisis se asigna al proyecto una certificación según calidad basada en letras. Durante el desarrollo se ha intentado mantener una Certificación A, la más alta. 

El análisis del proyecto se puede encontrar \url{https://app.codacy.com/project/IvanBeke/TFG-Visor-de-espectros/dashboard}

\subsection{Monitorización de dependencias}

\subsubsection{Requires.io}

Esta herramienta analiza las dependencias del proyecto en busca de nuevas versiones e informa cuando una ha sacado nueva versión. También es capaz de mostrar la licencia de software que posee la dependencia y de ofrecer un enlace a su repositorio.

\subsubsection{Snyk}

Esta herramienta analiza las dependencias de nuestro proyecto para informar al usuario de vulnerabilidades de las mismas, de tal forma que pueda estar preparado contra ellas.

\section{Despliegue}

\subsection{Alojamienta}

\subsection{Nanobox}

\section{Almacenamiento}

\subsection{Sistema de almacenamiento}

\subsection{Explorador}

\section{Librerías}

\section{Librerías de representación}

\subsection{Dash}
Librería en Python que permite crear sitios webs completos para representación
de datos. Para ello hace uso de diversas tecnologías, \textit{Flask} para el
servidor web, \textit{Plotly} para la representación y \textit{React} para los
componentes y actualización.
\subsubsection{Pros}
\begin{itemize}
	\item Gráficos interactivos
	\item Fácil actualización del gráfico en la web mediante \verb|@app.callback|
	\item Integración de elementos HTML para la actualización del gráfico
	\item Uso de la librería \textit{cufflinks} para unir generar una figura
	directamente de un \textit{DataFrame}
	\item Al ser de los creadores de \textit{Plotly} y usarlo internamente da la
	posibilidad de usar sus componentes
	\item Al usar \textit{Flask} como servidor tiene acceso a todas sus ventajas
\end{itemize}
\subsubsection{Contras}
\begin{itemize}
	\item El código HTML hay que escribirlo desde el código de Python, esto hace
	que se complique el mantenimiento
	\item No se pueden reutilizar las plantillas de \textit{Flask}
\end{itemize}

\subsection{Plotly}
Plataforma para representación de datos, dispone de varias librerías para
diferentes lenguajes de programación. Representación online y offline.
\subsubsection{Pros}
\begin{itemize}
	\item Gráficos interactivos
	\item Posibilidad de uso con \textit{Flask} y \textit{Jupyter}
\end{itemize}
\subsubsection{Contras}
\begin{itemize}
	\item Para representar en la web hay que hacer uso de dos versiones de la
	librería, para Python y para JavaScript
	\item La representación online guarda los gráficos generados en una cuenta
	asociada de la plataforma
	\item La representación offline devuelve el gráfico en Python, pero para
	representarlo es necesario convertirlo a JSON, enviarlo a la web y que la parte
	de JS lo represente
	\item La actualización es necesaria hacerla desde el cliente con JS, donde no
	se dispone de los datos ni de las utilidades de minería de datos
\end{itemize}

\section{Infraestructura}
\subsection{Jupyter Notebook}
Aplicación web que permite la edición y ejecución de código, Python en este
caso, en el navegador, donde también se muestran el resultado de la ejecución.
Dispone de \textit{widgets} para interactuar con el programa. Se instala
localmente.
\subsubsection{Pros}
\begin{itemize}
	\item Fácil subir archivos al servidor en el menú principal
	\item Al no tener que hacer una interfaz web permite centrarse en la
	programación del código de minería de datos
	\item Los gráficos generados con \textit{Plotly} se representan directamente en
	el notebook
	\item Posibilidad de usar \url{https://mybinder.org/} para el despliegue
	\item Actualización del gráfico por medio de los \textit{widgets} e
	\verb|interact|
\end{itemize}
\subsubsection{Contras}
\begin{itemize}
	\item Menos usable e intuitivo
	\item Al estar el código expuesto el cliente podría alterarlo sin querer
	\item
	\href{http://jupyter-notebook.readthedocs.io/en/latest/public_server.html}{Solo
		se puede un usuario en servidor público}
\end{itemize}

\subsection{Flask}
Microframework para aplicaciones web en Python. Aunque por si solo
\textit{Flask} no sea muy completo, dispone de una gran cantidad de extensiones
oficiales y de la comunidad para suplir todas las características de un
framework web completo.
\subsubsection{Pros}
\begin{itemize}
	\item Maneja bien la subida de ficheros
	\item Al ser web hay más control sobre lo que puede hacer el usuario y sobre lo
	que se le presenta, con la finalidad de hacer más usable la aplicación
	\item Reutilización de código HTML mediante plantillas y macros
\end{itemize}
\subsubsection{Contras}
\begin{itemize}
	\item Mucho más trabajo al tener que diseñar y programar la interfaz web
\end{itemize}

\section{Despliegue}
\url{https://www.youtube.com/watch?v=vGphzPLemZE}\\
\url{https://gumroad.com/l/python-deployments}\\
\url{https://www.fullstackpython.com/platform-as-a-service.html}\\
\url{https://www.fullstackpython.com/servers.html}
\subsection{Heroku}
Plataforma como servicio, la forma más fácil de despliegue. Tan escalable como
fondo tenga la cartera. \url{https://www.heroku.com/}\\

El almacenamiento no es permanente, hay que usar servicios de terceros y
conectarlos mediante plugin.
\subsection{Ngrok}
Túnel seguro desde Internet hasta un servidor local en tu máquina. Dirección
aleatoria cada vez que se enciende. \url{https://ngrok.com/}\\

El almacenamiento es permanente porque es el almacenamiento de la máquina.
\subsection{Digital Ocean}
Solo de pago pero de momento está disponible por el pack educacional de GitHub.
Tan escalable como fondo tenga la cartera. VPS.\\
\url{https://www.digitalocean.com/}\\
\url{https://pythonprogramming.net/basic-flask-website-tutorial/}\\

Dispone del almacenamiento que ofrece la máquina virtual, es permanente. En caso
de que ese espacio sea insuficiente se puede agregar más pagando.
\subsection{Google App Engine, Google Cloud Platform}
Despliegue de Google como plataforma como servicio o VPS. Periodo de prueba
gratis y luego tan escalable como fondo tenga la cartera. Funciona con Python
2.7\\
\url{https://cloud.google.com/appengine/docs/standard/python/getting-started/python-standard-env}\\
\url{https://cloud.google.com/appengine/docs/standard/python/tools/uploadinganapp}\\
\url{https://cloud.google.com/python/getting-started/hello-world}\\
\url{https://cloud.google.com/appengine/docs/flexible/python/quickstart}\\

Ofrece formas de almacenamiento de Google como Cloud Storage para ficheros, caso
que nos interesa, hay que pagar por ellas.
\subsection{Open Shitf}
Plataforma como servicio. Plan básico gratis y plan profesional de pago, tan
escalable como fondo tenga la cartera.\\
\url{https://www.openshift.com/}\\
\url{https://blog.openshift.com/beginners-guide-to-writing-flask-apps-on-openshift/}\\
\url{https://blog.openshift.com/how-to-install-and-configure-a-python-flask-dev-environment-deploy-to-openshift/}\\

No ofrece almacenamiento por defecto, lo ofrece por medio de lo que llaman
``PersistentVolume'', ofrecen una API para comunicarse con ello.
\subsection{PythonAnywhere} 
Plataforma como servicio especializada en Python. Varios planes, a mejor plan
más caro. El plan más básico es gratis.\\
\url{https://www.pythonanywhere.com/}\\
\url{https://www.youtube.com/watch?v=M-QRwEEZ9-8}\\
Ofrecen almacenamiento de serie pero muy limitado y de pago.
\subsection{AWS Elastic Beanstalk,  AWS CodeStar}
Solución en la nube de Amazon. VPS. Tan escalable como fondo tenga la cartera.\\
\url{https://aws.amazon.com/es/elasticbeanstalk/}\\
\url{https://aws.amazon.com/es/codestar/}\\

Al igual que en el caso de Google, ofrece almacenamiento persistente con sus
servicios, Amazon S3, los cuales hay que pagar.
\subsection{AWS Lambda, Zappa}
Zappa es un capa por encima de AWS Lambda para desplegar en modo
\textit{serverless}. AWS Lambda se ocupa del escalado y Zappa del despliegue.\\
\url{https://github.com/Miserlou/Zappa}\\

Solo almacenamiento temporal.
\subsection{Docker}
Despliegue en contenedores.\\
\url{https://www.docker.com/}\\

De serie no tiene almacenamiento persistente pero es capaz de ofrecerlo mediante
``storage drivers''. Requiere bastante configuración.
\subsection{Azure}
Solución en la nube de Microsoft. VPS. Tan escalable como fondo tenga la
cartera.\\
\url{https://azure.microsoft.com/es-es/}\\
\url{https://docs.microsoft.com/en-us/azure/app-service/app-service-web-get-started-python}\\

Sí ofrece almacenamiento persistente.
\subsection{Nanobox}\label{nanobox}
Solución interesante, combina los contenedores de Docker con despliegue en la
nube y lo automatiza. De momento compatibilidad con Digital Ocean, Amazon y
Linode, Google, Joyent y Azure en camino. Plan básico gratis, el resto de
precios son flexibles. También en local.\\
\url{https://nanobox.io/}\\
\url{https://github.com/nanobox-io/nanobox}\\

Ofrece almacenamiento persistente, hay que configurar las rutas que van a ser
persistentes en el fichero de configuración. Cada despliegue el almacenamiento
que se haya usado so borra. Depende del almacenamiento que esté disponible en el
servicio escogido para almacenar.
